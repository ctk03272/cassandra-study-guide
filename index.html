<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cassandra Mastery Roadmap - The Ultimate Expert Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --bg-main: #fafaf9;
            /* stone-50 */
            --accent: #f59e0b;
            /* amber-500 */
            --text-dark: #1c1917;
            /* stone-900 */
        }

        body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: var(--bg-main);
            color: var(--text-dark);
            scroll-behavior: smooth;
        }

        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 350px;
            max-height: 400px;
        }

        .sidebar-active-phase {
            color: var(--accent);
            font-weight: 700;
            background-color: #fffbeb;
        }

        .sidebar-active-topic {
            background-color: #fef3c7;
            /* amber-100 */
            color: #92400e;
            /* amber-800 */
            font-weight: 600;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #d6d3d1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a29e;
        }

        .content-fade {
            animation: fadeIn 0.4s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .cap-node {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .cap-node.selected {
            background-color: var(--accent);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 10px 15px -3px rgba(245, 158, 11, 0.4);
        }

        .cap-edge {
            transition: all 0.3s ease;
            stroke: #e7e5e4;
            stroke-width: 4;
        }

        .cap-edge.highlight {
            stroke: var(--accent);
        }

        pre {
            background-color: #1c1917;
            color: #f5f5f4;
            padding: 1.5rem;
            border-radius: 0.75rem;
            font-size: 0.875rem;
            overflow-x: auto;
            margin: 1.5rem 0;
            border-left: 4px solid var(--accent);
        }

        .prose h3 {
            margin-top: 2.5rem;
            border-bottom: 1px solid #e7e5e4;
            padding-bottom: 0.5rem;
            color: #1c1917;
            font-weight: 800;
        }

        .prose h4 {
            margin-top: 1.5rem;
            color: #444;
            font-weight: 700;
        }

        .prose blockquote {
            border-left: 4px solid #f59e0b;
            padding-left: 1rem;
            font-style: italic;
            color: #666;
            background: #fffbeb;
            padding: 1rem;
            border-radius: 0.5rem;
        }

        .code-box {
            background-color: #292524;
            color: #e7e5e4;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            font-size: 0.85rem;
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        /* Production Tips & Anti-Patterns */
        .prod-tip {
            border-left: 4px solid #10b981;
            /* emerald-500 */
            background-color: #ecfdf5;
            /* emerald-50 */
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1.5rem 0;
            color: #065f46;
            /* emerald-800 */
        }

        .prod-tip strong {
            display: block;
            margin-bottom: 0.25rem;
            color: #047857;
        }

        .anti-pattern {
            border-left: 4px solid #ef4444;
            /* red-500 */
            background-color: #fef2f2;
            /* red-50 */
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1.5rem 0;
            color: #991b1b;
            /* red-800 */
        }

        .anti-pattern strong {
            display: block;
            margin-bottom: 0.25rem;
            color: #b91c1c;
        }
    </style>
</head>

<body class="antialiased">

    <div class="flex flex-col lg:flex-row min-h-screen">
        <!-- Sidebar Navigation -->
        <aside
            class="lg:w-80 bg-white border-r border-stone-200 p-6 flex flex-col sticky top-0 lg:h-screen z-20 overflow-y-auto">
            <div class="flex items-center gap-3 mb-10 cursor-pointer" onclick="location.reload()">
                <div
                    class="w-10 h-10 bg-amber-500 rounded-xl flex items-center justify-center text-white font-bold text-xl shadow-lg shadow-amber-200">
                    C</div>
                <div>
                    <h1 class="font-bold text-stone-900 leading-none text-lg">Cassandra Mastery</h1>
                    <p class="text-[10px] text-stone-400 mt-1 uppercase tracking-widest font-semibold">Ultimate Learning
                        Guide</p>
                </div>
            </div>

            <nav class="flex-1 space-y-4" id="sidebar-nav">
                <!-- Navigation tree injected here -->
            </nav>

            <div class="mt-10 p-5 bg-stone-50 rounded-2xl border border-stone-100">
                <div class="text-[10px] font-bold text-stone-400 uppercase tracking-wider mb-2 text-center">전체 학습 진척도
                </div>
                <div class="w-full bg-stone-200 h-1.5 rounded-full overflow-hidden">
                    <div id="total-progress-bar" class="bg-amber-500 h-full transition-all duration-700"
                        style="width: 0%"></div>
                </div>
                <div class="flex justify-between mt-2 text-[10px] font-bold text-stone-600 uppercase">
                    <span id="progress-text">0%</span>
                    <span>Production Ready</span>
                </div>
            </div>
        </aside>

        <!-- Main Content Area -->
        <main class="flex-1 flex flex-col min-h-screen bg-stone-50 overflow-y-auto">
            <div class="p-6 lg:p-12 max-w-5xl mx-auto w-full">
                <div id="main-display" class="content-fade">
                    <!-- Content injected here via JS -->
                </div>
            </div>
        </main>
    </div>

    <script>
        const phases = [
            {
                id: 1,
                title: "Phase 1: 분산 아키텍처 철학 (Architecture)",
                overview: "Cassandra는 '어떻게' 저장하느냐보다 '어디에' 저장하느냐가 더 중요한 시스템입니다. 마스터가 없는 P2P 구조의 본질과 수학적 배경을 이해해야만 운영 중 발생하는 기이한 현상들을 해석할 수 있습니다.",
                topics: [
                    {
                        id: "1.1",
                        name: "CAP 이론과 Network Partition의 현실",
                        desc: "Distributed System에서 'P'는 선택이 아닌 필수 조건입니다.",
                        detail: `
                        <h3>1. Core Concept: CAP의 오해와 진실</h3>
                        <p>CAP 이론에서 3가지를 동시에 만족할 수 없다는 것은 유명하지만, 실제로는 <strong>P(Partition Tolerance)</strong>를 전제로 C(Consistency)와 A(Availability) 중 하나를 Trade-off 하는 것입니다.</p>
                        <ul class="list-disc ml-5 space-y-2 mt-2">
                            <li><strong>Network Partition(망 분리) 상황:</strong> 케이블 절단이나 스위치 장애로 클러스터가 두 그룹으로 쪼개져 서로 통신할 수 없는 상황을 말합니다. 이건 물리적으로 피할 수 없습니다.</li>
                            <li><strong>CP 시스템 (MongoDB, HBase):</strong> "데이터가 달라지느니 응답을 거부하겠다." → 쇼핑몰 결제는 실패 처리됨.</li>
                            <li><strong>AP 시스템 (Cassandra, DynamoDB):</strong> "틀린 데이터라도 보여주겠다." → 장바구니에 담기긴 함 (나중에 동기화).</li>
                        </ul>

                        <h3>2. Deep Dive: Split-Brain & LWW Resolution</h3>
                        <p>네트워크가 단절(Split)되어 A노드엔 '100원', C노드엔 '200원'이 기록되었습니다. 나중에 합쳐질 때 카산드라는 <strong>어떻게 합의할까요?</strong></p>
                        
                        <div class="bg-stone-100 p-4 rounded-xl mb-4 border border-stone-200">
                            <strong>🏆 Winner: Last Write Wins (LWW)</strong>
                            <p class="mt-1 text-sm text-stone-600">모든 데이터에는 <strong>마이크로초 타임스탬프</strong>가 붙습니다. <br>
                            복구 시 <strong>가장 늦은 시간(최근)</strong>의 데이터만 남기고 나머지는 가차 없이 버립니다.</p>
                        </div>
                        
                        <h3>3. Historical Context: Vector Clock</h3>
                        <p>초기 NoSQL(Amazon Dynamo)은 "충돌 내용을 다 보존하자"는 <strong>Vector Clock</strong>을 썼지만, 카산드라는 <strong>복잡도 제거</strong>를 위해 LWW를 택했습니다. <br>
                        이 때문에 카산드라 운영자가 <strong>NTP(시간 동기화)</strong>를 안 맞추면 데이터가 과거로 덮어씌워지는 대참사가 일어납니다.</p>

                        <h3>4. Production Reality</h3>
                        <div class="prod-tip">
                            <strong>💡 Hinted Handoff (임시 보관)</strong>
                            <p>네트워크가 끊겨서 복제본을 못 보내면, 코디네이터 노드가 "나중에 줄게" 하고 <strong>Hint</strong>를 로컬에 저장합니다. 
                            이는 AP 시스템이 가용성을 유지하는 핵심 기술입니다. 단, 3시간(기본값)이 지나면 영구 유실될 수 있으니 <strong>Repair</strong>가 필수입니다.</p>
                        </div>
                    `,
                        vizType: "cap-interactive"
                    },
                    {
                        id: "1.2",
                        name: "Gossip Protocol & Failure Detection",
                        desc: "마스터 없이 서로의 생존을 확인하는 전염병 알고리즘",
                        detail: `
                        <h3>1. Core Concept: Epidemic Algorithm</h3>
                        <p>중앙 마스터(Zookeeper 등)가 있으면 그 녀석이 죽으면 끝입니다. 카산드라는 노드들이 서로 랜덤하게 짝을 지어 1초마다 "나 살아있고, 내가 아는 다른 애들의 상태는 이래"라고 소문을 퍼뜨립니다.</p>

                        <h3>2. Deep Dive: Phi Accrual Failure Detector</h3>
                        <p>단순히 "3초 동안 응답 없으면 사망"으로 판단하지 않습니다. 네트워크는 원래 불안정하니까요. <br>
                        카산드라는 응답 지연 시간의 분포를 통계적으로 계산하여 <strong>Phi(φ)</strong> 값을 산출합니다.</p>
                        <ul class="list-disc ml-5 space-y-2 mt-2">
                            <li>수학적 의미: "이 노드가 정상인데 우연히 이렇게 늦을 확률"을 로그 스케일로 계산.</li>
                            <li><strong>Phi = 8 (기본값):</strong> 약 0.000001%의 확률로 오판 가능성 (매우 보수적).</li>
                            <li>이 덕분에 '잠깐 느려진 노드'를 '죽은 노드'로 오판하여 불필요한 복구 작업을 시작하는 것을 방지합니다.</li>
                        </ul>

                        <h3>3. Recursive: Seed Node의 역할</h3>
                        <div class="bg-stone-100 p-4 rounded-xl mt-3">
                            <strong>❓ 모든 노드가 Seed가 되면 안 되나요?</strong><br>
                            새 노드가 클러스터에 합류할 때 "누구한테 인사하지?"를 정하는 게 Seed입니다. 
                            모두가 Seed면 Gossip 트래픽이 폭증합니다. 리전당 2~3개면 충분합니다.
                        </div>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "1.3",
                        name: "Shared-Nothing Architecture",
                        desc: "선형 확장성(Linear Scalability)의 비밀",
                        detail: `
                        <h3>1. Concept: 무공유 구조</h3>
                        <p>오라클 RAC처럼 스토리지(SAN)를 공유하면 락(Lock) 경합 때문에 확장에 한계가 옵니다. 카산드라는 각 노드가 CPU, RAM, Disk를 독점하며, 서로 아무것도 공유하지 않습니다.</p>

                        <h3>2. Example: 용량 증설 시나리오</h3>
                        <p>100TB 데이터를 10대(대당 10TB)가 처리 중인데 느려졌다면? <br>
                        그냥 10대를 더 꽂으면 정확히 성능이 2배가 됩니다. (마스터 병목이 없으므로)</p>
                        
                        <h3>3. Deep Dive: Coordinator Overhead</h3>
                        <p>클라이언트가 어떤 노드에 요청하든, 그 노드가 <strong>Coordinator</strong>가 되어 실제 데이터가 있는 노드(Replica)들에게 명령을 대리 수행합니다. 
                        따라서 노드 하나를 늘리면 '저장소'만 늘어나는 게 아니라 '접수 창구'도 같이 늘어나는 셈입니다.</p>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "1.4",
                        name: "Consistent Hashing & Token Ring",
                        desc: "데이터 위치 결정론: 길 잃은 데이터는 없다",
                        detail: `
                        <h3>1. Core Concept: Hash Function</h3>
                        <p>데이터 위치를 별도의 '주소록'에 저장하지 않습니다. 함수 <code>f(key)</code>의 결과가 곧 주소입니다.</p>
                        <div class="code-box">
                            Token = Murmur3Hash(Partition_Key)<br>
                            Range: -2^63 ~ +2^63 (약 1800경)
                        </div>

                        <h3>2. Deep Dive: Why Murmur3?</h3>
                        <p>카산드라의 기본 파티셔너입니다. 핵심은 <strong>"입력값의 패턴을 완전히 파괴하여 균등하게 뿌리는 것"</strong>입니다.</p>
                        <ul class="list-disc ml-5 space-y-2 mt-2">
                            <li><strong>Avalanche Effect (쇄도 효과):</strong> 입력값이 1비트만 바뀌어도 결과값은 평균적으로 50% 이상의 비트가 바뀝니다.</li>
                            <li><strong>Example:</strong>
                                <ul class="list-disc ml-5 text-sm text-stone-600">
                                    <li>Key "user_001" -&gt; Token -4823... (Node A)</li>
                                    <li>Key "user_002" -&gt; Token +1054... (Node C)</li>
                                    <li>Key "user_003" -&gt; Token +8821... (Node E)</li>
                                </ul>
                            </li>
                            <li><strong>Anti-Pattern (ByteOrdered):</strong> 만약 알파벳 순서대로 저장한다면(ByteOrderedPartitioner), 'user'로 시작하는 데이터가 특정 노드에만 몰리는 <strong>Hotspot</strong>이 발생합니다. Murmur3는 이를 수학적으로 방지합니다.</li>
                        </ul>

                        <h3>3. Visualizing the Ring: The "Clockwise Rule"</h3>
                        <p>이 "링(Ring)"은 카산드라가 다룰 수 있는 <strong>모든 데이터의 주소 공간</strong>(-2^63 ~ +2^63)을 둥글게 말아놓은 지도입니다.</p>
                        <div class="code-box">
                            <strong>🎯 데이터 배정 알고리즘 (핵심)</strong><br>
                            1. 데이터(Key)가 해시 함수를 통해 링 위의 <strong>어떤 지점</strong>에 떨어집니다.<br>
                            2. 그 지점에서 <strong>시계 방향(Clockwise)</strong>으로 돌면서 <strong>가장 먼저 만나는 노드</strong>가 그 데이터의 주인(Owner)이 됩니다.<br>
                            3. 복제본(Replica)은? 링을 계속 돌면서 만나는 다음 노드들에게 차례로 저장됩니다.
                        </div>
                        <p>즉, 링 구조 덕분에 "내 데이터가 어디 있는지"를 중앙 서버에 물어볼 필요 없이, 해시값만 알면 누구나 찾아갈 수 있습니다.</p>
                    `,
                        vizType: "ring-simulation"
                    },
                    {
                        id: "1.5",
                        name: "Virtual Nodes (Vnodes)",
                        desc: "물리적 노드를 논리적 조각으로 분해하다",
                        detail: `
                        <h3>1. Problem & Solution: Parallel Streaming</h3>
                        <p>과거(v1.2 이전)에는 노드를 추가하면 기존 1대의 노드가 자기 데이터의 50%를 몽땅 전송하느라 네트워크가 마비되었습니다. <br>
                        <strong>Vnode</strong>는 물리 노드 1개를 수백 개의 작은 논리 조각(토큰)으로 다져서 링 전체에 흩뿌립니다. 이제 노드 추가 시 <strong>모든 노드가 조금씩 데이터를 나누어 주므로(Parallel Streaming)</strong> 부하가 분산됩니다.</p>

                        <h3>2. Deep Dive: The Overhead of "256"</h3>
                        <p>초기 권장값은 <code>num_tokens: 256</code>이었지만, 이는 예상치 못한 부작용을 낳았습니다.</p>
                        <ul class="list-disc ml-5 space-y-2 mt-2">
                            <li><strong>Gossip Storm:</strong> 100대 클러스터라면 25,600개의 토큰 위치 정보를 1초마다 교환해야 합니다. CPU 부하가 심각해집니다.</li>
                            <li><strong>Repair Complexity:</strong> 데이터 복구 작업도 256조각으로 잘게 쪼개져 관리되므로 트래킹 비용이 증가합니다.</li>
                        </ul>

                        <h3>3. Production Trend (v4.0+)</h3>
                        <div class="prod-tip">
                            <strong>💡 New Best Practice: 4 or 16 Tokens</strong>
                            <p>최신 할당 알고리즘의 발달로 256개까지 쪼개지 않아도 충분히 데이터 분산이 잘 됩니다. <br>
                            요즘 운영 환경에서는 오버헤드를 줄이기 위해 <code>cassandra.yaml</code>에서 <strong>num_tokens: 16</strong> 정도로 낮추는 것이 글로벌 표준(Standard)이 되고 있습니다.</p>
                        </div>
                    `,
                        vizType: "none"
                    }
                ]
            },
            {
                id: 2,
                title: "Phase 2: 쿼리 기반 데이터 모델링 (Data Modeling)",
                overview: "RDBMS 모델링은 '개체(Entity)' 중심이지만, Cassandra는 '쿼리(Query)' 중심입니다. Join이 없기 때문에 화면에 필요한 데이터를 미리 조립해서 저장해야 합니다 (Query-First Design).",
                topics: [
                    {
                        id: "2.1",
                        name: "Partition Key: 데이터의 위치를 정하다",
                        desc: "클러스터 성능을 결정짓는 가장 중요한 선택",
                        detail: `
                        <h3>1. Core Concept: The Router & Locality</h3>
                        <p><strong>Partition Key</strong>는 데이터가 '어느 노드'에 저장될지를 결정하는 유일한 기준입니다. <br>
                        또한, <strong>"함께 조회되는 데이터는 함께 저장되어야 한다"</strong>는 데이터 지역성(Locality)의 핵심 키입니다.</p>

                        <h3>2. Deep Dive: Composite Partition Key</h3>
                        <p>파티션 키를 여러 컬럼으로 조합하여 정교하게 데이터를 배치할 수 있습니다.</p>
                        <div class="code-box">
                            <strong>PRIMARY KEY ((team_id, year), match_id)</strong><br>
                            - <code>team_id</code>만 쓰면? 한 팀의 10년 치 데이터가 한 파티션에 쌓여 너무 커집니다.<br>
                            - <code>year</code>를 조합하면? 연도별로 파티션이 쪼개져 적절한 크기를 유지합니다.
                        </div>

                        <h3>3. Critical Rule: High Cardinality</h3>
                        <p>파티션 키는 종류가 많을수록(High Cardinality) 좋습니다. <br>
                        예를 들어 '성별(남/여)'을 파티션 키로 쓰면 클러스터가 100대라도 단 2대의 노드만 일을 하게 됩니다. 
                        <strong>User ID, Device ID</strong> 처럼 수만~수억 개의 고유한 값을 가진 컬럼을 선택해야 합니다.</p>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "2.2",
                        name: "Clustering Key: 데이터 정렬의 마법",
                        desc: "Disk Seek를 최소화하는 물리적 정렬 구조",
                        detail: `
                        <h3>1. Core Concept: On-Disk Sorting</h3>
                        <p>데이터가 파티션 내에서 <strong>미리 정렬(Pre-sorted)</strong>되어 저장됩니다. 이 덕분에 카산드라는 수억 건의 데이터 중 특정 시간 범위만 읽어오는 작업을 <strong>Random I/O 없이</strong> 수행합니다.</p>

                        <h3>2. Deep Dive: Efficient Range Scan (Slice Query)</h3>
                        <p>이 기능이 없다면 카산드라는 단순 Key-Value Store에 불과했을 겁니다.</p>
                        <div class="code-box">
                            <strong>Query:</strong><br>
                            SELECT * FROM messages <br>
                            WHERE room_id = 'A' <br>
                            AND <strong>created_at &gt; '2024-01-01'</strong>;<br><br>
                            <strong>Internal:</strong><br>
                            디스크 헤드가 '2024-01-01' 위치로 점프(Seek)한 뒤, 그 뒤의 데이터만 순차적(Sequential)으로 읽습니다.
                        </div>

                        <h3>3. Advanced: Multi-Column Clustering</h3>
                        <p><code>CLUSTERING KEY (year, month, day)</code> 처럼 여러 컬럼을 지정하면, 디렉토리 구조처럼 계층적으로 정렬됩니다. <br>
                        이렇게 하면 <code>WHERE year=2024 AND month=5</code> 같은 복합 조건 검색도 인덱스 없이 고속으로 가능해집니다.</p>

                        <h3>4. Pro Pattern: "Latest 10" Query</h3>
                        <p>시계열 데이터에서 가장 흔한 요구사항은 '최신 글 10개' 조회입니다.</p>
                        <div class="code-box">
                            <strong>WITH CLUSTERING ORDER BY (date DESC)</strong>
                        </div>
                        <p>이 옵션을 쓰면 최신 데이터가 디스크의 <strong>맨 앞(Head)</strong>에 저장됩니다.<br>
                        따라서 <code>SELECT * ... LIMIT 10</code> 쿼리는 전체를 뒤질 필요 없이, 디스크 앞부분만 살짝 읽고(O(1)) 바로 리턴합니다. 이것이 카산드라가 시계열 DB로 각광받는 이유입니다.</p>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "2.3",
                        name: "Denormalization & No JOIN",
                        desc: "Join은 비싸다, 디스크는 싸다",
                        detail: `
                        <h3>1. Core Concept: Why No JOIN?</h3>
                        <p>분산 시스템에서 JOIN을 하려면 A노드의 테이블과 B노드의 테이블을 네트워크로 끌어와서 메모리에서 합쳐야 합니다. 
                        데이터가 페타바이트 단위라면 이는 불가능합니다.</p>

                        <h3>2. Example: 유저 정보 변경</h3>
                        <p>사용자가 닉네임을 바꾸면? RDBMS는 User테이블 1곳만 고치면 되지만, 카산드라는:</p>
                        <ol class="list-decimal ml-5 space-y-1">
                            <li>Users 테이블</li>
                            <li>Comments_By_User 테이블</li>
                            <li>Reviews_By_User 테이블</li>
                        </ol>
                        <p>위 3곳의 데이터를 모두 비동기로 업데이트해야 합니다. "쓰기 복잡도"를 높여서 "읽기 성능"을 사는 전략입니다.</p>

                        <div class="prod-tip">
                            <strong>💡 Chebychev's Inequality</strong>
                            <p>실리콘밸리 격언: "데이터 중복을 두려워하면 NoSQL을 쓸 자격이 없다."</p>
                        </div>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "2.4",
                        name: "Wide Partition: 물리적 한계와 해결",
                        desc: "20억 개의 셀 제한과 실무적인 파티션 분할 전략",
                        detail: `
                        <h3>1. Deep Dive: 2 Billion Cells Limit</h3>
                        <p>왜 하필 20억 개일까요? 카산드라 내부 코드(Java)에서 오프셋 인덱스를 관리할 때 <strong>signed 32-bit integer</strong>를 사용하기 때문입니다. 
                        이 이상 커지면 오버플로우로 데이터가 손상되거나 조회가 불가능해집니다.</p>

                        <h3>2. Production Advice: Ideal Partition Size</h3>
                        <div class="prod-tip">
                            <strong>📏 Best Practice: Under 100 MB</strong>
                        </div>
                        <p>20억 개는 '기술적 한계'일 뿐이고, 성능상 권장 크기는 <strong>100MB 미만</strong>입니다.<br>
                        파티션이 수 GB가 되면:</p>
                        <ul class="list-disc ml-5 space-y-1 text-sm text-stone-600">
                            <li>메모리로 로딩 시 JVM Heap OOM 유발</li>
                            <li>Compaction 작업 시 디스크 I/O 폭발</li>
                            <li>노드 복구(Repair) 속도 극단적 저하</li>
                        </ul>
                        
                        <div class="anti-pattern">
                            <strong>🚫 Anti-Pattern: Queue Model</strong>
                            <p>작업 큐(Queue)처럼 데이터를 넣었다 뺐다 하는 테이블은 최악입니다. 
                            데이터는 지웠지만 툼스톤이 파티션 내에 쌓이면서, 물리적 파티션 크기는 줄어들지 않고 스캔 속도만 느려집니다.</p>
                        </div>

                        <h3>2. Solution: Bucketing Visualization</h3>
                        <div class="code-box">
                            PRIMARY KEY ((sensor_id, month), timestamp)
                        </div>
                        <p>이렇게 하면 1월 데이터는 Node A에, 2월 데이터는 Node B에 분산될 수도 있어 핫스팟과 대형 파티션 문제를 동시에 해결합니다.</p>
                    `,
                        vizType: "mermaid-diagram",
                        mermaidContent: `
                        graph LR
                            A[Problem: Wide Partition] -->|Too Many Rows| B(Compaction OOM)
                            A -->|Slow Read| C(Linear Scan required)
                            
                            D[Solution: Bucketing] --> E{Partition Key}
                            E -->|Keys| F((Sensor_1 : 2024-01))
                            E -->|Keys| G((Sensor_1 : 2024-02))
                            E -->|Keys| H((Sensor_1 : 2024-03))
                            
                            F --> I[Small Chunk]
                            G --> J[Small Chunk]
                            H --> K[Small Chunk]
                        `
                    },
                    {
                        id: "2.5",
                        name: "Secondary Index vs Materialized View",
                        desc: "편리함의 유혹과 성능의 함정",
                        detail: `
                        <h3>1. Deep Dive: Secondary Index Internal</h3>
                        <p><code>user_email</code>에 인덱스를 걸고 조회하면? <br>
                        코디네이터 노드는 <strong>클러스터의 모든 노드</strong>에게 "너네 중에 이 이메일 가진 애 있어?"라고 물어봅니다 (Scatter/Gather). <br>
                        노드가 100개면 100번의 네트워크 요청이 발생합니다. 절대 대용량 트래픽을 감당할 수 없습니다.</p>

                        <h3>2. Alternative: Materialized View (MV)</h3>
                        <p>카산드라가 내부적으로 별도의 테이블을 만들고 데이터를 복제해주는 기능입니다. Scatter/Gather 문제는 없지만, 
                        <strong>Eventual Consistency</strong> 이슈로 원본 테이블에는 데이터가 있는데 뷰에는 아직 없을 수 있습니다.</p>

                        <div class="prod-tip">
                            <strong>💡 Best Practice</strong>
                            <p>그냥 애플리케이션 레벨에서 두 테이블(Base + Search용)에 동시에 쓰는 것(Dual Write)이 가장 제어하기 쉽고 안전합니다.</p>
                        </div>
                    `,
                        vizType: "none"
                    }
                ]
            },
            {
                id: 3,
                title: "Phase 3: CQL과 실무 오퍼레이션 (CQL & Operations)",
                overview: "SQL과 비슷해 보이지만 실상은 전혀 다릅니다. '왜 이 쿼리는 느린가?'를 이해하려면 CQL의 내부 동작 원리와 일관성 레벨(Consistency Level)의 기하학적 의미를 파악해야 합니다.",
                topics: [
                    {
                        id: "3.1",
                        name: "Consistency Level (CL) 상세 제어",
                        desc: "쿼리 한 건 단위로 정합성과 응답 속도의 균형 잡기",
                        detail: `
                        <h3>1. Concept: 튜닝 가능한 일관성</h3>
                        <p>RDBMS는 트랜잭션 격리 레벨(Isolation Level)을 세션 단위로 정하지만, 카산드라는 <strong>쿼리 단위</strong>로 '몇 명의 복제본이 대답해야 성공인지' 정할 수 있습니다.</p>

                        <h3>2. Deep Dive: 주요 CL 동작 매트릭스</h3>
                        <table class="w-full text-xs text-left border-collapse border border-stone-200 mb-4 mt-2">
                            <tr class="bg-stone-100"><th class="p-2 border">Level</th><th class="p-2 border">설명</th><th class="p-2 border">시나리오</th></tr>
                            <tr><td class="p-2 border font-bold">ANY</td><td class="p-2 border">아무 노드나 OK (Hinted Handoff 포함).</td><td class="p-2 border">로그 수집 (가용성 100%, 0% Consistency)</td></tr>
                            <tr><td class="p-2 border font-bold">ONE</td><td class="p-2 border">1개 복제본만 확인. 가장 빠름.</td><td class="p-2 border">추천 시스템, 클릭 스트림</td></tr>
                            <tr><td class="p-2 border font-bold">QUORUM</td><td class="p-2 border">(N/2 + 1)개 확인. 강한 일관성.</td><td class="p-2 border">계정 정보, 결제 내역</td></tr>
                            <tr><td class="p-2 border font-bold">LOCAL_QUORUM</td><td class="p-2 border">같은 DC 내의 과반수 확인.</td><td class="p-2 border text-green-600"><strong>운영 표준 (Multi-DC 필수)</strong></td></tr>
                        </table>

                        <h3>3. Recursive: Digest Mismatch</h3>
                        <p>읽기 요청 시, 코디네이터는 1개의 <strong>Full Data</strong> 요청과 나머지에겐 <strong>Digest(해시값)</strong> 요청을 보냅니다. 해시가 다르면(즉, 데이터 불일치), 백그라운드에서 <strong>Read Repair</strong>를 트리거하여 최신 데이터로 동기화합니다.</p>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "3.2",
                        name: "R + W > N 공식: Quorum 정합성의 수학",
                        desc: "수학적으로 증명된 강한 일관성(Strong Consistency) 원리",
                        detail: `
                        <h3>1. Core Concept: 비둘기집 원리</h3>
                        <p>단순한 산수입니다. 복제본이 3개(N=3)일 때, 2개(W)에 쓰고 2개(R)에서 읽으면 반<strong>드시 1개의 노드는 겹칩니다</strong>. 이 겹치는 노드가 최신 데이터를 가지고 있으므로, 전체 시스템은 항상 최신 데이터를 리턴함을 보장합니다.</p>

                        <h3>2. Example Calculation</h3>
                        <div class="code-box">
                            Case A: N=3, W=1, R=1 <br>
                            -> 1 + 1 = 2 <= 3 (Strong Consistency 실패)<br><br>
                            Case B: N=3, W=QUORUM(2), R=QUORUM(2) <br>
                            -> 2 + 2 = 4 > 3 (Strong Consistency 성공)
                        </div>

                        <h3>3. Deep Dive: Latency Impact</h3>
                        <p>R/W를 높이면 정합성은 좋아지지만, 응답 속도는 <strong>가장 느린 노드</strong>에 맞춰지게 됩니다. (Tail Latency). <br>
                        따라서 '무조건 QUORUM'이 정답은 아니며, 비즈니스 요건에 따라 유연하게 섞어 써야 합니다.</p>

                        <h3>4. Pro Tip: Speculative Retry</h3>
                        <p>그렇다면 QUORUM 시 느린 노드 하나 때문에 전체가 느려질까요? 카산드라는 <strong>"보내놓고 기다리기"</strong> 전략을 씁니다.</p>
                        <div class="code-box">
                            <strong>Speculative Retry: 99percentile</strong><br>
                            - 처음엔 필요 수만큼(예: 2개)만 요청을 보냅니다.<br>
                            - 만약 응답이 P99 시간보다 늦어지면? 즉시 <strong>예비 노드(3번째)</strong>에 추가 요청을 쏘고, 가장 빨리 온 응답을 채택합니다.
                        </div>
                    `,
                        vizType: "consistency"
                    },
                    {
                        id: "3.3",
                        name: "Upsert와 툼스톤: 실무 문제 해결",
                        desc: "쓰기/삭제 패턴에 따른 성능 저하 예방과 해결책",
                        detail: `
                        <h3>1. Deep Dive: The Shadow of Death</h3>
                        <p>카산드라에서 <code>DELETE</code>는 사실 <code>INSERT</code>입니다. "이 데이터는 죽었음"이라는 마커(Tombstone)를 <strong>새로 쓰는 것</strong>입니다. 진짜 삭제는 10일(gc_grace_seconds) 뒤 Compaction 때 일어납니다.</p>

                        <h3>2. Production Alert: The "Doomstone"</h3>
                        <div class="prod-tip">
                            <strong>💥 상황 발생:</strong> <br>
                            List 컬럼에 데이터를 100만 번 넣었다 뺐다 했습니다. 데이터는 0건인데 조회 쿼리는 10초 걸립니다. 왜?<br>
                            -> <strong>100만 개의 Tombstone</strong>을 읽어서 "아, 다 지워졌네" 하고 필터링하는 시간이 10초인 겁니다.
                        </div>

                        <h3>3. Prevention & Fix</h3>
                        <ul>
                            <li><strong>Query:</strong> 컬럼 삭제/업데이트 대신, 전체 Row에 TTL을 걸거나 Partition 단위 삭제를 지향하세요.</li>
                            <li><strong>Compaction:</strong> 삭제가 잦다면 STCS 대신 <strong>LCS</strong>를 써서 Tombstone을 더 빨리 청소하게 하세요.</li>
                        </ul>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "3.4",
                        name: "ALLOW FILTERING의 위험성",
                        desc: "왜 파티션 키 없는 검색은 운영 금지인가?",
                        detail: `
                        <h3>1. Context: "Why is my query failed?"</h3>
                        <p>개발자가 파티션 키가 아닌 컬럼으로 조회를 시도할 때 이 에러를 만납니다.</p>
                        <div class="code-box">
                            SELECT * FROM users WHERE <strong>age = 30</strong>;<br>
                            --> Error: Cannot execute this query as it might involve data filtering...
                        </div>
                        <p>카산드라는 "이 쿼리는 성능 망하니까 내가 안 해줄 거야"라고 거부하는 겁니다. 이때 <code>ALLOW FILTERING</code>을 붙이면 강제로 실행됩니다.</p>

                        <h3>2. Deep Dive: Global Table Scan</h3>
                        <p>이 옵션을 켜는 순간, 코디네이터는 클러스터의 <strong>모든 노드의 모든 데이터</strong>를 메모리로 퍼올린 뒤 하나씩 까봅니다(Filtering).</p>
                        <ul class="list-disc ml-5 space-y-1 mt-2 text-sm text-red-600">
                            <li><strong>CPU 100% Spike:</strong> 모든 데이터의 압축을 해제(Decompression)해야 함</li>
                            <li><strong>Cluster Outage:</strong> 단 한 개의 쿼리가 운영 중인 DB 전체를 멈출 수 있음</li>
                        </ul>

                        <h3>3. When to use?</h3>
                        <p><strong>Dev/Test 환경</strong>에서 데이터를 확인할 때만 쓰세요. 운영 환경(Prod) 코드에 이 구문이 있다면 버그입니다.</p>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "3.5",
                        name: "Batch & LWT: 성능의 양날의 검",
                        desc: "비싼 기능인 줄 모르고 쓰면 장애를 부릅니다.",
                        detail: `
                        <h3>1. Anti-Pattern: Batch for Bulk Load</h3>
                        <p>RDBMS처럼 <code>INSERT</code> 1만 개를 <code>BATCH</code>로 묶으면 빠를까요? <strong>절대 아닙니다.</strong></p>
                        <ul class="list-disc ml-5 space-y-1 mt-2 text-sm text-red-600">
                            <li><strong>Coordinator Bottleneck:</strong> 배치에 포함된 모든 데이터를 코디네이터 노드가 메모리에 들고 있다가, 각 파티션 담당 노드에게 분배해야 합니다. (메모리 폭발)</li>
                            <li><strong>Solution:</strong> 대량 입력은 비동기(Async) 병렬 요청으로 쏘는 게 훨씬 빠릅니다. 카산드라의 Batch는 오직 <strong>"원자성(Atomicity)"</strong> 보장용입니다.</li>
                        </ul>

                        <h3>2. Deep Dive: Lightweight Transaction (LWT)</h3>
                        <p><code>IF NOT EXISTS</code> 같은 구문은 <strong>Paxos 알고리즘</strong>을 써서 4번의 왕복(Round-trip)이 발생합니다. 일반 쓰기보다 <strong>4배 느립니다</strong>. 이걸 트래픽 많은 로직에 메인으로 쓰면 안 됩니다.</p>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "3.6",
                        name: "Pagination: 무한 스크롤의 진실",
                        desc: "OFFSET이 없는 이유와 효율적인 대용량 조회 전략",
                        detail: `
                        <h3>1. Concept: No OFFSET</h3>
                        <p>RDBMS의 <code>LIMIT 100 OFFSET 10000</code>은 앞의 1만 개를 읽고 버리는 비효율적 방식입니다. <br>
                        카산드라는 아예 <strong>OFFSET 키워드가 없습니다.</strong> 대신 '직전 페이지의 마지막 위치'를 기억했다가 그 다음부터 읽는 방식(Paging State)만 지원합니다.</p>

                        <h3>2. Deep Dive: Token-Aware Scan</h3>
                        <p>배치(Batch) 작업이나 마이그레이션을 위해 <strong>전체 데이터(10억 건)를 스캔</strong>해야 한다면? 단순 페이징은 중간에 타임아웃 나면 처음부터 다시 해야 합니다.</p>
                        <div class="code-box">
                            <strong>WHERE token(id) &gt; token(last_id) LIMIT 100</strong>
                        </div>
                        <p>카산드라는 <strong><code>token()</code>이라는 내장 함수</strong>를 제공합니다. 이를 통해 실제 파티션 키의 해시값(Token)을 기준으로 링을 한 바퀴 도는 순서대로 데이터를 안정적으로 읽어올 수 있습니다.</p>
                    `,
                        vizType: "none"
                    }
                ]
            },
            {
                id: 4,
                title: "Phase 4: 스토리지 엔진 내부 구조 (Storage Engine)",
                overview: "메모리의 속도와 디스크의 내구성을 합친 LSM-Tree 구조를 해부합니다. 쓰기가 어떻게 그토록 빠른지, 그리고 읽기가 왜 복잡한지 이해합니다.",
                topics: [
                    {
                        id: "4.1",
                        name: "Write Path: LSM Tree의 비밀",
                        desc: "왜 카산드라는 쓰기가 압도적으로 빠른가?",
                        detail: `
                        <h3>1. Concept: LSM Tree (Log-Structured Merge Tree)</h3>
                        <p>RDBMS의 <strong>B-Tree</strong>는 데이터를 수정할 때마다 디스크의 특정 위치를 찾아가야(Random I/O) 해서 느립니다.<br>
                        반면, <strong>LSM Tree</strong>는 <strong>"무조건 맨 뒤에 추가(Append Only)"</strong>만 합니다. 수정도, 삭제도 모두 새로운 쓰기로 처리합니다. 그래서 쓰기 속도가 SSD의 물리적 한계치까지 나옵니다.</p>

                        <h3>2. Deep Dive: The Write Flow</h3>
                        <ol class="list-decimal ml-5 space-y-2 mt-2">
                            <li><strong>CommitLog (Disk):</strong> 데이터가 유실되지 않도록 가장먼저 디스크에 로그를 남깁니다 (WAL). 순차 쓰기라 매우 빠릅니다.</li>
                            <li><strong>Memtable (RAM):</strong> 데이터를 메모리에 씁니다. 이때 <strong>SkipList</strong> 자료구조를 이용해 미리 정렬(Sorting)해 둡니다.</li>
                            <li><strong>Flush (SSTable):</strong> Memtable이 꽉 차면, 정렬된 데이터를 그대로 디스크에 쏟아붓습니다(Sequential Write). 이것이 <strong>SSTable</strong>입니다.</li>
                        </ol>

                        <h3>3. Why Append Only?</h3>
                        <p>디스크 헤드를 여기저기 움직이는 시간(Seek Time)을 0으로 만들기 위함입니다. 이것이 카산드라가 초당 수백만 건의 쓰기를 감당하는 비결입니다.</p>
                    `,
                        vizType: "write-path"
                    },
                    {
                        id: "4.2",
                        name: "Read Path: 읽기 파이프라인",
                        desc: "디스크를 최대한 읽지 않기 위한 4단계 방어막",
                        detail: `
                        <h3>1. Core Concept: Read = Merge</h3>
                        <p>읽기는 쓰기보다 훨씬 비쌉니다. 데이터가 Memtable과 여러 SSTable에 조각나 있기 때문입니다. 엔진은 이 조각들을 <strong>Merge</strong>하여 최신 내용만 리턴합니다.</p>

                        <h3>2. Deep Dive: Optimization Pipeline (방어막)</h3>
                        <p>SSTable을 뒤지는 건 느립니다. 그래서 메모리 단계에서 최대한 요청을 걸러냅니다.</p>
                        <ol class="list-decimal ml-5 space-y-3 mt-3">
                            <li><strong>Bloom Filter:</strong> "이 키가 여기 절대 없음"을 확률적으로 100% 보장. (False Positive 가능, False Negative 불가능)</li>
                            <li><strong>Key Cache:</strong> "이 키는 파일의 어디(Offset)에 있다"를 바로 알려줌. Hit하면 인덱스 스캔 생략.</li>
                            <li><strong>Partition Summary (RAM):</strong> 인덱스의 요약본을 메모리에 상주.</li>
                            <li><strong>Partition Index (Disk):</strong> 정확한 데이터 위치를 디스크 인덱스에서 찾음.</li>
                        </ol>

                        <h3>3. Production Reality: 왜 Bucketing이 중요한가?</h3>
                        <p>Bloom Filter의 메모리 사용량은 <strong>'유니크한 파티션 키의 개수'</strong>에 비례합니다 (10억 개 키 ≈ 1~2GB RAM).</p>
                        <div class="code-box">
                            - <strong>Bad:</strong> 매초마다 새로운 파티션 생성 (10억 개 파티션 → 메모리 폭발 💥)<br>
                            - <strong>Good (Bucketing):</strong> '시간+분'으로 묶음 (파티션 개수 1/60로 감소 → 메모리 절약 📉)
                        </div>
                        <p>즉, Bucketing은 단순히 데이터를 묶는 것을 넘어, <strong>Bloom Filter를 메모리에 무사히 안착시키기 위한 필수 기법</strong>입니다.</p>
                    `,
                        vizType: "read-path"
                    },
                    {
                        id: "4.3",
                        name: "Compaction 전략 (STCS, LCS, TWCS)",
                        desc: "데이터 수명과 워크로드에 맞는 디스크 정리 전략",
                        detail: `
                        <h3>1. Purpose: 왜 파일을 합치는가?</h3>
                        <p>조각난 SSTable이 많으면 읽기 성능이 떨어집니다. Compaction은 파일들을 병합(Merge Sort)하여 하나로 만들고, 이 과정에서 <strong>Tombstone(삭제된 데이터)을 물리적으로 제거(Eviction)</strong>합니다.</p>

                        <h3>2. Strategy Comparison Guide (Which one to use?)</h3>
                        <div class="space-y-4">
                            <!-- STCS -->
                            <div class="bg-stone-50 p-4 rounded-xl border border-stone-200">
                                <h4 class="font-bold text-amber-600 mb-2">STCS (Size Tiered) - Defualt</h4>
                                <ul class="text-xs list-disc ml-4 space-y-1 text-stone-600">
                                    <li><strong>Best For:</strong> 쓰기가 많은 일반적인 워크로드 (Write Heavy).</li>
                                    <li><strong>Use Case:</strong> IoT 데이터 수집, 일반적인 게시판 글쓰기.</li>
                                    <li><strong>주의점:</strong> 읽기 속도가 들쭉날쭉할 수 있음. 디스크 공간이 50% 이상 여유 있어야 안전함.</li>
                                </ul>
                            </div>
                            
                            <!-- LCS -->
                            <div class="bg-stone-50 p-4 rounded-xl border border-stone-200">
                                <h4 class="font-bold text-amber-600 mb-2">LCS (Leveled) - Read Optimized</h4>
                                <ul class="text-xs list-disc ml-4 space-y-1 text-stone-600">
                                    <li><strong>Best For:</strong> 쓰기보다 읽기가 훨씬 많은 경우 (Read:Write > 9:1).</li>
                                    <li><strong>Use Case:</strong> 유저 프로필 조회, 상품 메타데이터, 캐시용 DB.</li>
                                    <li><strong>주의점:</strong> 쓰기 작업(I/O)이 10배 이상 더 발생함. (Write Amplification)</li>
                                </ul>
                            </div>
                            
                            <!-- TWCS -->
                            <div class="bg-stone-50 p-4 rounded-xl border border-stone-200">
                                <h4 class="font-bold text-amber-600 mb-2">TWCS (Time Window) - Time Series</h4>
                                <ul class="text-xs list-disc ml-4 space-y-1 text-stone-600">
                                    <li><strong>Best For:</strong> TTL(만료 시간)이 설정된 시계열 데이터.</li>
                                    <li><strong>Use Case:</strong> 30일치 로그 저장, 채팅 히스토리, 센서 모니터링.</li>
                                    <li><strong>주의점:</strong> TTL 없이 쓰거나 중간 데이터를 수정/삭제하면 안 됨.</li>
                                </ul>
                            </div>
                        </div>
                    `,
                        vizType: "compaction-sim"
                    }
                ]
            },
            {
                id: 5,
                title: "Phase 5: Production 운영 및 고가용성 (Operations)",
                overview: "기능 개발은 끝이 아니라 시작입니다. 실제 트래픽을 받을 때 발생하는 장애 상황(노드 다운, 네트워크 단절)을 시뮬레이션하고 복구하는 '생존 기술'을 익힙니다.",
                topics: [
                    {
                        id: "5.1",
                        name: "Multi-DC: 왜 'Active-Active'인가?",
                        desc: "지구 반대편 데이터센터가 살아있다면, 서비스는 죽지 않는다.",
                        detail: `
                        <h3>1. Developer's Perspective: 앱 수정 0줄</h3>
                        <p>서울 리전이 지진으로 다운되어도, 개발자는 코드를 고칠 필요가 없습니다. 카산드라 드라이버가 알아서 <strong>살아있는 리전(US-East)</strong>으로 요청을 돌립니다. 이것이 진정한 HA(High Availability)입니다.</p>

                        <h3>2. Concept: NetworkTopologyStrategy</h3>
                        <p>데이터를 단순히 복제하는 게 아닙니다. <strong>"서울에 3개, 버지니아에 3개"</strong> 식으로 DC별 사본 개수를 지정하면, 엔진이 내부적으로 데이터를 전송합니다.</p>
                        <div class="code-box">
                            <strong>Consistency Tip:</strong> 글로벌 서비스라도 <code>LOCAL_QUORUM</code>을 쓰세요. <br>
                            - 서울 유저는 서울 노드 2개만 확인(Fast).<br>
                            - 미국 복제는 비동기로 진행(Async).
                        </div>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "5.2",
                        name: "Troubleshooting: 개발자를 위한 생존 도구",
                        desc: "서버가 느릴 때, 개발자가 당장 확인해야 할 3가지",
                        detail: `
                        <h3>1. 건강 검진: nodetool status</h3>
                        <p>서버가 살았는지(<strong>U</strong>p/<strong>D</strong>own) 죽었는지 판단합니다. 로드 밸런싱이 잘 되는지도 볼 수 있습니다.</p>

                        <h3>2. 병목 구간 찾기: nodetool tpstats</h3>
                        <p>"DB가 느려요"라는 말을 들으면 이걸 치세요. <strong>Pending</strong> 카운트가 높다면 서버가 과부하 상태입니다.</p>
                        <ul class="list-disc ml-5 space-y-1 mt-1 text-xs">
                            <li><strong>Native-Transport-Requests:</strong> 앱 요청이 너무 많음.</li>
                            <li><strong>MutationStage:</strong> 쓰기 작업이 밀림.</li>
                        </ul>

                        <h3>3. 데이터 모델 검증: nodetool tablestats</h3>
                        <p>내가 만든 테이블이 효율적인지 봅니다. <strong>Average partition size</strong>가 100MB를 넘으면 모델링 실패입니다.</p>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "5.3",
                        name: "Self-Healing: 자동 복구의 마법",
                        desc: "운영자가 자는 동안 데이터를 복구하는 원리 (Hinted Handoff)",
                        detail: `
                        <h3>1. Hinted Handoff: "부재중 쪽지" (임시 조치)</h3>
                        <p>서버 A가 잠깐 죽으면, 동료 서버 B가 <strong>"A에게 줄 데이터(쪽지)"</strong>를 대신 보관합니다. A가 살아나면 B가 쪽지를 전해줍니다. (최대 3시간)</p>
                        
                        <h3>2. Read Repair: "읽으면서 고친다" (게으른 조치)</h3>
                        <p>데이터를 읽었는데 사본끼리 내용이 다르면? <br>
                        -> <strong>"너네 왜 달라?"</strong> 하고 즉시 최신 데이터로 덮어씌웁니다. 많이 읽을수록 데이터가 깨끗해집니다.</p>

                        <h3>3. Simulation</h3>
                        <p>아래 시뮬레이터에서 <strong>노드를 강제로 죽여보세요(Kill Node).</strong> 다른 노드가 어떻게 데이터를 지켜주는지 볼 수 있습니다.</p>
                    `,
                        vizType: "ha-sim"
                    },
                    {
                        id: "5.4",
                        name: "백업 및 보안 설정 (Snapshot & RBAC)",
                        desc: "기업용 서비스를 위한 데이터 보호와 사용자 권한 관리",
                        detail: `
                        <h3>1. Zero-Cost Backup: Snapshot</h3>
                        <p>카산드라 백업은 놀랍도록 가볍습니다. SSTable이 불변(Immutable) 파일이라는 점을 이용해, OS 레벨의 <strong>Hard Link</strong>를 생성합니다. <br>
                        용량을 추가로 차지하지 않으면서도 수 초 만에 수 테라바이트 데이터의 시점 백업이 가능합니다.</p>

                        <h3>2. Deep Dive: RBAC (Role Based Access Control)</h3>
                        <p>DB 계정을 <code>cassandra</code> 슈퍼계정 하나로 돌려 쓰는 건 최악의 보안 위협입니다. 각 마이크로서비스(MSA) 별로 전용 Role을 만들고, 딱 필요한 Keyspace에만 권한(GRANT)을 부여해야 합니다.</p>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "5.5",
                        name: "Monitoring Core Metrics",
                        desc: "장애를 예고하는 골든 시그널 모니터링",
                        detail: `
                        <h3>1. The Golden Signals</h3>
                        <p>대시보드에 꼭 띄워야 할 3대 지표입니다.</p>
                        <div class="code-box">
                            1. <strong>Pending Compactions:</strong> 이게 늘어나면 디스크 I/O가 못 따라가는 것입니다. <br>
                            2. <strong>Dropped Mutations:</strong> 서버가 "나 너무 힘들어" 하고 요청을 갖다 버리는 중입니다. 즉시 증설 필요.<br>
                            3. <strong>GC Halt (>1s):</strong> Stop-the-world 시간이 길어지면 다른 노드들이 "쟤 죽었나봐" 하고 클러스터에서 추방하려 듭니다 (Flapping).
                        </div>
                    `,
                        vizType: "none"
                    }
                ]
            },
            {
                id: 6,
                title: "Phase 6: 성능 최적화 및 튜닝 (Performance)",
                overview: "기능 구현을 넘어 극한의 성능을 뽑아내는 단계입니다. JVM 가비지 컬렉션부터 OS 커널 파라미터까지, Full-stack 엔지니어링 튜닝을 배웁니다.",
                topics: [
                    {
                        id: "6.1",
                        name: "JVM Tuning (ZGC & Large Heap)",
                        desc: "Stop-the-world 없는 대용량 힙 구성 전략",
                        detail: `
                        <h3>1. ZGC: The Game Changer</h3>
                        <p>과거 G1GC나 CMS는 32GB 이상 힙을 쓰면 GC Pause가 길어졌습니다. JDK 17+의 <strong>ZGC</strong>는 128GB 힙에서도 <strong>Pause Time < 10ms</strong>를 보장합니다.</p>
                        <div class="code-box">
                            # jvm-server.options<br>
                            -XX:+UseZGC<br>
                            -Xmx64G<br>
                            -Xms64G  // Min/Max를 같게 설정하여 OS의 Memory resizing 방지
                        </div>

                        <h3>2. Off-Heap Memory</h3>
                        <p>데이터(Memtable)와 캐시(KeyCache)는 <strong>Off-Heap</strong>으로 빼서 GC 부하를 줄이는 것이 핵심입니다. 힙은 오직 요청 처리를 위한 '작업대'로만 써야 합니다.</p>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "6.2",
                        name: "OS Kernel & Disk Tuning",
                        desc: "DB 성능을 갉아먹는 OS 설정을 끄는 법",
                        detail: `
                        <h3>1. Swap Must Die (스왑 끄기)</h3>
                        <p>Java 프로세스가 스왑 영역으로 빠지는 순간, 성능은 수백 배 느려집니다. <code>swapoff -a</code>는 선택이 아닌 필수입니다.</p>
                        
                        <h3>2. Disk Optimization</h3>
                        <ul class="list-disc ml-5 space-y-1 mt-1 text-xs">
                            <li><strong>XFS Filesystem:</strong> ext4보다 대용량 파일 처리에 유리합니다.</li>
                            <li><strong>Read-Ahead (128KB):</strong> 카산드라는 랜덤 읽기가 많으므로, OS의 과도한 미리 읽기(보통 4MB)를 줄여야 합니다.</li>
                        </ul>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "6.3",
                        name: "Latency Magic: Speculative Retry",
                        desc: "느린 노드를 기다리지 않고 다른 노드에 재요청하는 기술",
                        detail: `
                        <h3>1. How it works?</h3>
                        <p>코디네이터 노드는 평소에 각 노드의 응답 속도를 학습합니다(Dynamic Snitch). <br>
                        만약 A노드가 평소보다 99% 느리다면? 타임아웃까지 기다리지 않고 <strong>즉시 B노드에 똑같은 요청</strong>을 하나 더 보냅니다 (Speculative Executions).</p>

                        <h3>2. Effect: P99 Latency Killer</h3>
                        <p>가끔씩 튀는 'Tail Latency(꼬리 지연)'를 잡는 데 마법 같은 효과를 발휘합니다. 일시적인 GC나 네트워크 지연을 사용자에게 숨길 수 있습니다.</p>
                    `,
                        vizType: "tuning"
                    },
                    {
                        id: "6.4",
                        name: "Client Driver Tuning",
                        desc: "TokenAwarePolicy를 모르면 낭패를 본다",
                        detail: `
                        <h3>1. TokenAwarePolicy (핵심)</h3>
                        <p>드라이버가 내 쿼리의 파티션 키가 어느 노드에 있는지 해싱을 통해 미리 압니다. <br>
                        -> 엄한 노드(Coordinator)를 거치지 않고, <strong>데이터가 있는 노드로 '직배송'</strong> 합니다. (Hop 감소)</p>

                        <h3>2. Connection Pooling</h3>
                        <p>소켓 연결을 맺고 끊는 비용은 비쌉니다. 앱 시작 시 노드당 1~2개의 Persistent Connection을 맺어두고 재사용하세요.</p>
                    `,
                        vizType: "none"
                    },
                    {
                        id: "6.3",
                        name: "클라이언트 드라이버 설정 튜닝",
                        desc: "Tail Latency를 잡는 Speculative Execution 정책",
                        detail: `
                        <h3>1. Advanced Concept: Speculative Execution</h3>
                        <p><strong>"느린 응답은 실패와 같다."</strong> <br>
                        특정 노드가 GC나 네트워크 이슈로 버벅거릴 때, 드라이버가 이를 감지하고(예: P99 지연시간 초과), <strong>즉시 다른 복제본 노드에 같은 쿼리를 한 번 더 보냅니다.</strong> <br>
                        먼저 오는 응답을 채택하고 나머지는 버립니다. 이를 통해 꼬리 지연(Tail Latency)을 획기적으로 줄입니다.</p>
                    `,
                        vizType: "tuning"
                    }
                ]
            }
        ];

        let currentPhaseIdx = 0;
        let currentTopicIdx = -1;
        let selectedCAP = [];
        const taskStatus = JSON.parse(localStorage.getItem('cassandra_team_progress')) || {};
        let charts = {};

        function init() {
            renderSidebar();
            loadPhaseOverview(0);
            updateOverallProgress();
            mermaid.initialize({ startOnLoad: false, theme: 'neutral' });
        }

        function renderSidebar() {
            const nav = document.getElementById('sidebar-nav');
            nav.innerHTML = phases.map((p, i) => {
                const isPhaseActive = (i === currentPhaseIdx && currentTopicIdx === -1);
                const isPhaseSelected = (i === currentPhaseIdx);

                return `
                <div class="space-y-1">
                    <button onclick="changePhase(${i})" class="w-full text-left px-3 py-2.5 rounded-xl text-sm font-bold transition-all hover:bg-stone-100 ${isPhaseActive ? 'sidebar-active-phase shadow-sm' : 'text-stone-600'}">
                        Phase ${p.id}: ${p.title.replace(/^Phase \d+: /, '')}
                    </button>
                    ${isPhaseSelected ? `
                        <div class="pl-4 space-y-1 border-l-2 border-stone-100 ml-3">
                            ${p.topics.map((t, j) => {
                    const isTopicActive = (i === currentPhaseIdx && j === currentTopicIdx);
                    const isDone = taskStatus[t.id];
                    return `
                                    <button onclick="changeTopic(${i}, ${j})" class="w-full text-left px-3 py-2 rounded-lg text-xs transition-all hover:bg-amber-50 flex items-start justify-between ${isTopicActive ? 'sidebar-active-topic' : 'text-stone-500'}">
                                        <span class="leading-tight text-[11px]">Topic ${t.id}: ${t.name}</span>
                                        ${isDone ? '<span class="text-emerald-500 font-bold ml-1 flex-shrink-0">✓</span>' : ''}
                                    </button>
                                `;
                }).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
            }).join('');
        }

        function changePhase(idx) {
            currentPhaseIdx = idx;
            currentTopicIdx = -1;
            renderSidebar();
            loadPhaseOverview(idx);
        }

        function changeTopic(pIdx, tIdx) {
            currentPhaseIdx = pIdx;
            currentTopicIdx = tIdx;
            renderSidebar();
            loadTopic(pIdx, tIdx);
        }

        function loadPhaseOverview(idx) {
            const phase = phases[idx];
            const display = document.getElementById('main-display');
            display.innerHTML = `
            <div class="space-y-8 content-fade">
                <header>
                    <div class="flex items-center gap-3 mb-2">
                        <span class="bg-amber-100 text-amber-600 px-3 py-1 rounded-full text-[10px] font-bold tracking-widest uppercase">Stage ${phase.id} Overview</span>
                    </div>
                    <h2 class="text-4xl font-extrabold text-stone-900 tracking-tight">${phase.title}</h2>
                    <p class="text-xl text-stone-500 mt-4 leading-relaxed max-w-3xl">${phase.overview}</p>
                </header>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    ${phase.topics.map((t, j) => `
                        <div onclick="changeTopic(${idx}, ${j})" class="bg-white p-6 rounded-3xl border border-stone-200 shadow-sm cursor-pointer hover:border-amber-500 transition-all group flex flex-col justify-between min-h-[160px]">
                            <div>
                                <span class="text-[10px] font-bold text-amber-500 uppercase tracking-tighter">Topic ${t.id}</span>
                                <h4 class="font-bold text-stone-800 mt-1 group-hover:text-amber-600 leading-tight">${t.name}</h4>
                            </div>
                            <p class="text-xs text-stone-400 mt-4 line-clamp-2">${t.desc}</p>
                        </div>
                    `).join('')}
                </div>
                <button onclick="changeTopic(${idx}, 0)" class="w-full py-5 bg-stone-900 text-white font-bold rounded-2xl hover:bg-black transition shadow-xl active:scale-[0.98]">
                    학습 시작하기 (Phase ${phase.id}.1)
                </button>
            </div>
        `;
        }

        function loadTopic(pIdx, tIdx) {
            const topic = phases[pIdx].topics[tIdx];
            const isChecked = taskStatus[topic.id] || false;
            const display = document.getElementById('main-display');

            const vizSectionHtml = topic.vizType !== 'none'
                ? `<section id="viz-section" class="bg-white p-8 rounded-[2rem] border border-stone-200 shadow-sm min-h-[350px] flex flex-col"></section>`
                : '';

            display.innerHTML = `
            <div class="space-y-8 content-fade">
                <header>
                    <div class="flex items-center gap-3 mb-2">
                        <span class="text-amber-500 font-bold text-xs tracking-widest uppercase">Learning Content</span>
                    </div>
                    <h2 class="text-4xl font-extrabold text-stone-900 tracking-tight">${topic.name}</h2>
                    <p class="text-lg text-stone-400 mt-2">${topic.desc || ""}</p>
                </header>
                <div id="topic-content" class="space-y-8">
                    ${vizSectionHtml}
                    <section class="bg-white p-10 rounded-[2rem] border border-stone-200 shadow-sm prose prose-stone max-w-none prose-h3:text-stone-900 prose-h3:font-bold prose-h3:mt-8 prose-p:text-stone-600 prose-li:text-stone-600">
                        <div id="topic-detail"></div>
                        <div class="mt-12 pt-8 border-t border-stone-100 flex flex-wrap gap-4 items-center justify-between">
                            <label class="flex items-center gap-4 cursor-pointer group bg-stone-50 px-6 py-3 rounded-2xl border border-stone-100 hover:border-amber-200 transition-all">
                                <input type="checkbox" class="w-6 h-6 accent-amber-500 rounded-lg" ${isChecked ? 'checked' : ''} onchange="toggleProgress('${topic.id}')">
                                <span class="text-sm font-bold text-stone-700 group-hover:text-amber-600 uppercase tracking-tighter">마스터 완료</span>
                            </label>
                            <div class="flex gap-3">
                                <button onclick="goBack()" class="px-6 py-3 rounded-2xl bg-white border border-stone-200 text-stone-500 text-sm font-bold hover:bg-stone-50 transition">뒤로가기</button>
                                <button onclick="goNext()" class="px-8 py-3 rounded-2xl bg-amber-500 text-white text-sm font-bold hover:bg-amber-600 transition shadow-lg shadow-amber-100">다음 단계</button>
                            </div>
                        </div>
                    </section>
                </div>
            </div>
        `;

            if (topic.vizType !== 'none') renderViz(topic);
            document.getElementById('topic-detail').innerHTML = topic.detail;
            document.getElementById('main-display').scrollTop = 0;
        }

        function renderViz(topic) {
            const container = document.getElementById('viz-section');
            container.innerHTML = '';

            if (topic.vizType === 'cap-interactive') {
                selectedCAP = [];
                container.innerHTML += `
                <div class="flex flex-col items-center justify-center space-y-12 py-4">
                    <div class="relative w-64 h-56">
                        <svg class="absolute inset-0 w-full h-full pointer-events-none">
                            <line id="edge-CA" x1="50%" y1="10%" x2="10%" y2="90%" class="cap-edge" />
                            <line id="edge-CP" x1="50%" y1="10%" x2="90%" y2="90%" class="cap-edge" />
                            <line id="edge-AP" x1="10%" y1="90%" x2="90%" y2="90%" class="cap-edge" />
                        </svg>
                        <div onclick="toggleCAP('C')" id="node-C" class="cap-node absolute top-0 left-1/2 -translate-x-1/2 w-20 h-20 bg-white border-2 border-stone-200 rounded-[1.5rem] flex flex-col items-center justify-center font-bold text-[10px] shadow-sm uppercase">C</div>
                        <div onclick="toggleCAP('A')" id="node-A" class="cap-node absolute bottom-0 left-0 w-20 h-20 bg-white border-2 border-stone-200 rounded-[1.5rem] flex flex-col items-center justify-center font-bold text-[10px] shadow-sm uppercase">A</div>
                        <div onclick="toggleCAP('P')" id="node-P" class="cap-node absolute bottom-0 right-0 w-20 h-20 bg-white border-2 border-stone-200 rounded-[1.5rem] flex flex-col items-center justify-center font-bold text-[10px] shadow-sm uppercase">P</div>
                    </div>
                    <div id="cap-result" class="text-center h-16 flex flex-col items-center justify-center bg-stone-50 px-8 rounded-2xl w-full max-w-md border border-stone-100"><p class="text-sm text-stone-400">속성을 클릭하세요.</p></div>
                </div>
            `;
            } else if (topic.vizType === 'ring-simulation') {
                container.innerHTML += `
                <div class="flex flex-col items-center justify-center space-y-6 py-2">
                    <canvas id="ringCanvas" width="300" height="300" class="max-w-full"></canvas>
                    <div class="flex gap-2 w-full max-w-xs">
                        <input type="text" id="ringKeyInput" placeholder="Hash Key (예: user123)" class="flex-1 p-3 text-xs border border-stone-200 rounded-xl outline-none focus:border-amber-500 bg-stone-50">
                        <button onclick="simulateHash()" class="px-6 py-3 bg-stone-900 text-white text-xs font-bold rounded-xl hover:bg-black transition shadow-lg">해싱</button>
                    </div>
                    <div id="ringResultBox" class="bg-amber-50 p-4 rounded-xl border border-amber-100 w-full max-w-sm hidden">
                        <p id="ringResultText" class="text-[11px] text-amber-900 text-center leading-relaxed font-medium"></p>
                    </div>
                </div>
            `;
                initRingCanvas();
            } else if (topic.vizType === 'consistency') {
                container.innerHTML += `
                <div class="flex flex-col items-center justify-center space-y-8 p-4 h-full">
                    <div class="flex gap-4 sm:gap-10 items-center justify-center flex-wrap">
                        <div class="text-center bg-stone-50 p-6 rounded-2xl border border-stone-100 shadow-sm min-w-[100px]">
                            <div class="text-[10px] font-bold text-stone-400 mb-3 uppercase tracking-tighter">RF (N)</div>
                            <input type="range" min="1" max="5" value="3" id="n-val" class="accent-amber-500 w-full mb-3" oninput="updateVizCL()">
                            <div class="text-3xl font-black text-stone-700" id="n-display">3</div>
                        </div>
                        <div class="text-3xl font-bold text-stone-200">+</div>
                        <div class="text-center bg-stone-50 p-6 rounded-2xl border border-stone-100 shadow-sm min-w-[100px]">
                            <div class="text-[10px] font-bold text-stone-400 mb-3 uppercase tracking-tighter">WRITE (W)</div>
                            <input type="range" min="1" max="3" value="1" id="w-val" class="accent-amber-500 w-full mb-3" oninput="updateVizCL()">
                            <div class="text-3xl font-black text-stone-700" id="w-display">1</div>
                        </div>
                        <div class="text-center bg-stone-50 p-6 rounded-2xl border border-stone-100 shadow-sm min-w-[100px]">
                            <div class="text-[10px] font-bold text-stone-400 mb-3 uppercase tracking-tighter">READ (R)</div>
                            <input type="range" min="1" max="3" value="1" id="r-val" class="accent-amber-500 w-full mb-3" oninput="updateVizCL()">
                            <div class="text-3xl font-black text-stone-700" id="r-display">1</div>
                        </div>
                    </div>
                    <div id="cl-result" class="w-full max-w-lg p-8 rounded-[2rem] text-center font-bold transition-all duration-300 shadow-xl border"></div>
                </div>
            `;
                updateVizCL();
            } else if (topic.vizType === 'write-path') {
                container.innerHTML += `

                <div class="relative flex flex-col items-center justify-center space-y-12 py-10 h-full overflow-hidden">
                    <div class="flex items-center gap-10">
                        <div class="relative">
                            <div class="w-24 h-24 bg-white border-2 border-stone-200 rounded-[2rem] flex items-center justify-center font-bold text-stone-400 text-[10px] shadow-sm uppercase tracking-widest">Client</div>
                            <div id="data-packet" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-6 h-6 bg-amber-500 rounded-full opacity-0 shadow-lg shadow-amber-200 z-10"></div>
                        </div>
                        
                        <div class="flex flex-col gap-6">
                            <div id="memtable" class="w-40 p-5 bg-white border-2 border-amber-100 rounded-2xl text-center shadow-sm relative">
                                <span class="absolute -left-3 top-1/2 -translate-y-1/2 bg-amber-100 text-amber-600 text-[10px] font-bold px-2 py-1 rounded-full border border-amber-200">2</span>
                                <div class="font-bold text-stone-600 text-xs">Memtable</div>
                                <div class="text-[10px] text-stone-400 mt-1">Memory (RAM)</div>
                            </div>
                            <div id="commitlog" class="w-40 p-5 bg-stone-800 rounded-2xl text-center border border-stone-900 shadow-md relative">
                                <span class="absolute -left-3 top-1/2 -translate-y-1/2 bg-stone-600 text-stone-100 text-[10px] font-bold px-2 py-1 rounded-full border border-stone-500">1</span>
                                <div class="font-bold text-stone-300 text-xs">CommitLog</div>
                                <div class="text-[10px] text-stone-500 mt-1">Disk (Append)</div>
                            </div>
                        </div>

                        <div id="sstable" class="w-28 h-52 bg-stone-100 rounded-[1.5rem] border-b-[12px] border-stone-300 flex flex-col items-center justify-center text-center -rotate-2 shadow-xl relative">
                            <span class="absolute -top-3 left-1/2 -translate-x-1/2 bg-blue-100 text-blue-600 text-[10px] font-bold px-2 py-1 rounded-full border border-blue-200 z-20">3</span>
                            <div class="font-bold text-stone-400 text-[10px] uppercase mb-1">Disk</div>
                            <div class="font-black text-stone-400 text-xl tracking-tighter">SSTable</div>
                            <div class="text-[9px] text-stone-400 mt-2">Immutable</div>
                        </div>
                    </div>
                    <button onclick="runWriteAnim()" class="px-10 py-4 bg-amber-500 text-white rounded-2xl font-bold hover:bg-amber-600 transition shadow-lg active:scale-95 flex items-center gap-2">
                        <span>▶ 쓰기 시뮬레이션 시작</span>
                    </button>
                    <p id="anim-status" class="text-xs text-stone-500 font-medium h-4"></p>
                </div>
            `;
            } else if (topic.vizType === 'read-path') {
                container.innerHTML += `
                <div class="relative flex flex-col items-center justify-center space-y-8 py-6 h-full overflow-hidden w-full">
                    <!-- Client -->
                    <div class="relative z-10">
                        <div class="w-16 h-12 bg-white border border-stone-200 rounded-xl flex items-center justify-center font-bold text-stone-400 text-[10px] shadow-sm uppercase tracking-widest">Client</div>
                        <div id="read-packet" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-4 h-4 bg-blue-500 rounded-full opacity-0 shadow-lg shadow-blue-200 z-50"></div>
                    </div>

                    <!-- Pipeline -->
                    <div class="flex gap-2 w-full max-w-2xl justify-center items-start h-[180px] relative">
                        <!-- 1. Memtable -->
                        <div id="rp-mem" class="flex-1 h-32 bg-white border border-stone-200 rounded-xl flex flex-col items-center p-2 shadow-sm transition-all duration-300">
                            <span class="text-[9px] font-bold text-stone-400 uppercase mb-1">1. Memtable</span>
                            <div class="w-full h-full bg-stone-50 rounded-lg flex items-center justify-center text-[10px] text-stone-300">Check RAM</div>
                        </div>
                        
                        <!-- 2. Bloom Filter -->
                        <div id="rp-bf" class="flex-1 h-32 bg-white border border-stone-200 rounded-xl flex flex-col items-center p-2 shadow-sm transition-all duration-300">
                            <span class="text-[9px] font-bold text-stone-400 uppercase mb-1">2. Bloom Filter</span>
                            <div class="w-full h-full bg-stone-50 rounded-lg flex items-center justify-center text-[10px] text-stone-300 text-center px-1">Maybe? / No!</div>
                        </div>

                        <!-- 3. Key Cache -->
                        <div id="rp-cache" class="flex-1 h-32 bg-white border border-stone-200 rounded-xl flex flex-col items-center p-2 shadow-sm transition-all duration-300">
                            <span class="text-[9px] font-bold text-stone-400 uppercase mb-1">3. Key Cache</span>
                            <div class="w-full h-full bg-stone-50 rounded-lg flex items-center justify-center text-[10px] text-stone-300">Offset?</div>
                        </div>

                        <!-- 4. SSTable -->
                        <div id="rp-sst" class="flex-1 h-32 bg-stone-100 border border-stone-200 rounded-xl flex flex-col items-center p-2 shadow-sm transition-all duration-300">
                            <span class="text-[9px] font-bold text-stone-400 uppercase mb-1">4. SSTable</span>
                            <div class="w-full h-full bg-stone-200 rounded-lg flex items-center justify-center text-[10px] text-stone-400">Disk Seek</div>
                        </div>
                    </div>

                    <button onclick="runReadAnim()" class="px-8 py-3 bg-blue-500 text-white rounded-xl text-xs font-bold hover:bg-blue-600 transition shadow-lg active:scale-95 flex items-center gap-2">
                        <span>▶ 읽기 시뮬레이션 시작</span>
                    </button>
                    <p id="read-status" class="text-xs text-stone-500 font-medium h-4"></p>
                </div>
            `;
            } else if (topic.vizType === 'modeling') {
                container.innerHTML += `
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 h-full p-4">
                    <div class="flex flex-col"><h4 class="text-[10px] font-bold text-stone-400 mb-2 uppercase ml-2">MySQL (RDBMS)</h4><div class="p-5 bg-stone-900 rounded-[1.5rem] font-mono text-[10px] text-stone-300 overflow-auto shadow-inner border border-stone-800 h-[200px]">CREATE TABLE users (...);<br>CREATE TABLE orders (...);<br><br>SELECT * FROM orders JOIN users...</div></div>
                    <div class="flex flex-col"><h4 class="text-[10px] font-bold text-stone-400 mb-2 uppercase ml-2">Cassandra (NoSQL)</h4><div class="p-5 bg-stone-800 rounded-[1.5rem] font-mono text-[10px] text-stone-100 overflow-auto shadow-inner border border-stone-700 h-[200px]">CREATE TABLE orders_by_user (...);<br><br>SELECT * FROM orders_by_user WHERE...</div></div>
                </div>
            `;
            } else if (topic.vizType === 'radar') {
                container.innerHTML += `<div class="chart-container"><canvas id="radarChart"></canvas></div>`;
                initRadarChart();
            } else if (topic.vizType === 'tuning') {
                container.innerHTML += `<div class="chart-container"><canvas id="barChart"></canvas></div><p class="text-center text-[10px] text-stone-400 mt-4 italic font-medium">최적화 지표 예측</p>`;
                initBarChart();
            } else if (topic.vizType === 'mermaid-diagram') {
                container.innerHTML += `<div class="mermaid flex justify-center p-4">${topic.mermaidContent}</div>`;
                mermaid.init(undefined, document.querySelectorAll('.mermaid'));
            } else if (topic.vizType === 'compaction-sim') {
                container.innerHTML += `
                    <div class="flex flex-col items-center w-full">
                        <div class="flex gap-2 mb-4">
                            <button onclick="simCompaction('STCS')" class="px-3 py-1 bg-stone-200 rounded hover:bg-stone-300 text-xs font-bold">STCS</button>
                            <button onclick="simCompaction('LCS')" class="px-3 py-1 bg-stone-200 rounded hover:bg-stone-300 text-xs font-bold">LCS</button>
                            <button onclick="simCompaction('TWCS')" class="px-3 py-1 bg-stone-200 rounded hover:bg-stone-300 text-xs font-bold">TWCS</button>
                        </div>
                        <div id="compaction-area" class="w-full h-48 bg-stone-100 rounded-xl relative overflow-hidden border border-stone-200 p-2 flex items-end gap-1"></div>
                        <p id="sim-desc" class="text-[10px] text-stone-500 mt-2">버튼을 눌러 시뮬레이션 시작</p>
                    </div>
                `;
            } else if (topic.vizType === 'ha-sim') {
                container.innerHTML += `
                    <div class="flex flex-col items-center w-full gap-8 py-4">
                        <!-- Nodes Container -->
                        <div class="flex gap-12 items-center justify-center relative">
                            <!-- Node A -->
                            <div class="relative flex flex-col items-center gap-2">
                                <div id="ha-node-a" class="w-20 h-20 bg-emerald-500 rounded-full flex items-center justify-center text-white font-bold text-lg shadow-xl transition-all border-4 border-white ring-2 ring-emerald-200 z-10">A</div>
                                <div id="hint-badge-a" class="absolute -top-2 -right-2 bg-amber-500 text-white text-[9px] font-bold px-1.5 py-0.5 rounded-full hidden animate-bounce">HINT</div>
                            </div>
                            <!-- Node B -->
                            <div class="relative flex flex-col items-center gap-2">
                                <div id="ha-node-b" class="w-20 h-20 bg-emerald-500 rounded-full flex items-center justify-center text-white font-bold text-lg shadow-xl transition-all border-4 border-white ring-2 ring-emerald-200 z-10">B</div>
                                <span class="absolute -bottom-6 text-[10px] text-stone-400 font-bold uppercase tracking-widest">Replica 1</span>
                            </div>
                            <!-- Node C -->
                            <div class="relative flex flex-col items-center gap-2">
                                <div id="ha-node-c" class="w-20 h-20 bg-emerald-500 rounded-full flex items-center justify-center text-white font-bold text-lg shadow-xl transition-all border-4 border-white ring-2 ring-emerald-200 z-10">C</div>
                                <span class="absolute -bottom-6 text-[10px] text-stone-400 font-bold uppercase tracking-widest">Replica 2</span>
                            </div>
                        </div>
                        
                        <!-- Controls -->
                        <div class="flex gap-3 bg-white p-2 rounded-xl shadow-sm border border-stone-100">
                            <button onclick="runHASimAction('kill')" class="px-5 py-2 bg-rose-500 text-white rounded-lg text-xs font-bold hover:bg-rose-600 shadow transition active:scale-95">🔥 Kill Node A</button>
                            <button onclick="runHASimAction('write')" class="px-5 py-2 bg-sky-500 text-white rounded-lg text-xs font-bold hover:bg-sky-600 shadow transition active:scale-95">💾 Write Data</button>
                            <button onclick="runHASimAction('revive')" class="px-5 py-2 bg-emerald-500 text-white rounded-lg text-xs font-bold hover:bg-emerald-600 shadow transition active:scale-95">🚑 Revive Node A</button>
                        </div>
                        
                        <!-- Console -->
                        <div class="w-full max-w-lg bg-stone-900 rounded-xl p-4 font-mono text-[11px] leading-relaxed shadow-inner border border-stone-800">
                            <div class="flex items-center gap-2 border-b border-stone-800 pb-2 mb-2">
                                <span class="w-2 h-2 rounded-full bg-red-500"></span>
                                <span class="w-2 h-2 rounded-full bg-yellow-500"></span>
                                <span class="w-2 h-2 rounded-full bg-green-500"></span>
                                <span class="text-stone-500 ml-auto">system.log</span>
                            </div>
                            <div id="ha-log" class="h-24 overflow-y-auto flex flex-col gap-1 text-stone-300">
                                <div><span class="text-blue-400">[INFO]</span> Cluster started. All nodes UP.</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        function toggleCAP(type) {
            const index = selectedCAP.indexOf(type);
            if (index > -1) selectedCAP.splice(index, 1);
            else if (selectedCAP.length < 2) selectedCAP.push(type);
            else { selectedCAP.shift(); selectedCAP.push(type); }
            updateCAPUI();
        }

        function updateCAPUI() {
            ['C', 'A', 'P'].forEach(t => {
                const node = document.getElementById("node-" + t);
                if (node) selectedCAP.includes(t) ? node.classList.add('selected') : node.classList.remove('selected');
            });
            ['CA', 'CP', 'AP'].forEach(e => {
                const line = document.getElementById("edge-" + e);
                if (line) {
                    const eTypes = e.split('');
                    selectedCAP.includes(eTypes[0]) && selectedCAP.includes(eTypes[1]) ? line.classList.add('highlight') : line.classList.remove('highlight');
                }
            });
            const result = document.getElementById('cap-result');
            if (result) {
                if (selectedCAP.length < 2) result.innerHTML = "<p class='text-sm text-stone-400'>속성을 클릭하세요.</p>";
                else {
                    const sorted = selectedCAP.slice().sort().join('');
                    let text = ""; let subtext = "";
                    if (sorted === "AC") { text = "RDBMS (CA)"; subtext = "장애 시 시스템이 중단되더라도 정합성을 지킵니다."; }
                    else if (sorted === "AP") { text = "Cassandra (AP)"; subtext = "가용성을 위해 일시적인 불일치를 허용합니다."; }
                    else if (sorted === "CP") { text = "MongoDB (CP)"; subtext = "정합성을 위해 장애 시 응답을 거부합니다."; }
                    result.innerHTML = "<p class='text-base font-bold text-amber-600 uppercase'>" + text + "</p><p class='text-[10px] text-stone-500 font-medium'>" + subtext + "</p>";
                }
            }
        }

        function initRingCanvas() {
            drawRing();
        }

        function drawRing(highlightAngle = null) {
            const canvas = document.getElementById('ringCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 90;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.beginPath(); ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = "#e7e5e4"; ctx.lineWidth = 4; ctx.stroke();
            const nodes = [{ label: "Node A", angle: 0, color: "#f59e0b" }, { label: "Node B", angle: Math.PI * 0.5, color: "#3b82f6" }, { label: "Node C", angle: Math.PI, color: "#ef4444" }, { label: "Node D", angle: Math.PI * 1.5, color: "#10b981" }];
            nodes.forEach(node => {
                const x = centerX + Math.cos(node.angle) * radius; const y = centerY + Math.sin(node.angle) * radius;
                ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI * 2); ctx.fillStyle = "white"; ctx.fill(); ctx.strokeStyle = node.color; ctx.lineWidth = 3; ctx.stroke();
                ctx.fillStyle = "#a8a29e"; ctx.font = "bold 9px Inter"; ctx.textAlign = "center"; ctx.fillText(node.label, x, y - 16);
            });
            if (highlightAngle !== null) {
                const hx = centerX + Math.cos(highlightAngle) * radius; const hy = centerY + Math.sin(highlightAngle) * radius;
                ctx.beginPath(); ctx.arc(hx, hy, 6, 0, Math.PI * 2); ctx.fillStyle = "#1c1917"; ctx.fill();
                let owner = nodes[0]; const normAngle = (highlightAngle + Math.PI * 2) % (Math.PI * 2);
                for (let i = 0; i < nodes.length; i++) { if (normAngle <= nodes[i].angle) { owner = nodes[i]; break; } }
                if (normAngle > nodes[nodes.length - 1].angle) owner = nodes[0];
                ctx.beginPath(); ctx.moveTo(hx, hy); ctx.lineTo(centerX + Math.cos(owner.angle) * radius, centerY + Math.sin(owner.angle) * radius);
                ctx.strokeStyle = "#d6d3d1"; ctx.setLineDash([4, 4]); ctx.stroke(); ctx.setLineDash([]);
            }
        }

        function simulateHash() {
            const input = document.getElementById('ringKeyInput').value;
            if (!input) return;
            let hash = 0; for (let i = 0; i < input.length; i++) hash = input.charCodeAt(i) + ((hash << 5) - hash);
            const angle = ((Math.abs(hash) % 360) / 360) * Math.PI * 2;
            drawRing(angle);
            const resBox = document.getElementById('ringResultBox');
            resBox.classList.remove('hidden');
            document.getElementById('ringResultText').innerText = "해싱 완료. 시계 방향 원칙에 따라 담당 노드가 결정됩니다.";
        }

        function updateVizCL() {
            const nInput = document.getElementById('n-val');
            if (!nInput) return;
            const n = parseInt(document.getElementById('n-val').value);
            const w = parseInt(document.getElementById('w-val').value);
            const r = parseInt(document.getElementById('r-val').value);
            document.getElementById('n-display').innerText = n;
            document.getElementById('w-display').innerText = w;
            document.getElementById('r-display').innerText = r;
            const result = document.getElementById('cl-result');
            if (r + w > n) { result.innerHTML = "Strong Consistency: 성공"; result.className = "w-full max-w-lg p-8 rounded-3xl text-center font-bold bg-emerald-50 text-emerald-700 border border-emerald-100 shadow-xl shadow-emerald-50/50"; }
            else { result.innerHTML = "Eventual Consistency: 위험"; result.className = "w-full max-w-lg p-8 rounded-3xl text-center font-bold bg-amber-50 text-amber-700 border border-amber-100 shadow-xl shadow-amber-50/50"; }
        }

        function runReadAnim() {
            const packet = document.getElementById('read-packet');
            const mem = document.getElementById('rp-mem');
            const bf = document.getElementById('rp-bf');
            const cache = document.getElementById('rp-cache');
            const sst = document.getElementById('rp-sst');
            const status = document.getElementById('read-status');

            if (!packet) return;

            // Reset
            packet.style.transition = 'none';
            packet.style.opacity = '1';
            packet.style.transform = 'translate(-50%, -50%)';
            status.innerHTML = "1. 요청 시작: Memtable(RAM) 먼저 확인";

            // Step 1: Memtable
            setTimeout(() => {
                packet.style.transition = 'all 0.6s ease-out';
                packet.style.transform = 'translate(-200px, 60px)'; // To Memtable
                if (mem) mem.classList.add('border-blue-500', 'bg-blue-50');

                // Step 2: Bloom Filter
                setTimeout(() => {
                    status.innerHTML = "2. 데이터 없음 → Bloom Filter 확인 (SSTable에 있을까?)";
                    packet.style.transform = 'translate(-60px, 60px)'; // To BF
                    if (mem) mem.classList.remove('border-blue-500', 'bg-blue-50');
                    if (bf) bf.classList.add('border-blue-500', 'bg-blue-50');

                    // Step 3: Key Cache
                    setTimeout(() => {
                        status.innerHTML = "3. 아마 있음(Positive) → Key Cache 확인 (위치는?)";
                        packet.style.transform = 'translate(60px, 60px)'; // To Cache
                        if (bf) bf.classList.remove('border-blue-500', 'bg-blue-50');
                        if (cache) cache.classList.add('border-blue-500', 'bg-blue-50');

                        // Step 4: SSTable
                        setTimeout(() => {
                            status.innerHTML = "<span class='text-blue-600 font-bold'>4. Offset 획득 → Disk Seek & Return!</span>";
                            packet.style.transform = 'translate(200px, 60px)'; // To SSTable
                            if (cache) cache.classList.remove('border-blue-500', 'bg-blue-50');
                            if (sst) sst.classList.add('border-blue-500', 'bg-blue-100');

                            setTimeout(() => {
                                packet.style.opacity = '0';
                                if (sst) sst.classList.remove('border-blue-500', 'bg-blue-100');
                                status.innerHTML = "";
                            }, 2000);
                        }, 1000);
                    }, 1000);
                }, 1000);
            }, 100);
        }
        function runWriteAnim() {
            const packet = document.getElementById('data-packet');
            const mem = document.getElementById('memtable');
            const cl = document.getElementById('commitlog');
            const ss = document.getElementById('sstable');
            const status = document.getElementById('anim-status');

            if (!packet) return;

            // Reset
            packet.style.transition = 'none';
            packet.style.opacity = '1';
            packet.style.transform = 'translate(-50%, -50%)';
            status.innerHTML = "1. Client가 쓰기 요청을 보냅니다...";

            setTimeout(() => {
                // Step 1: Write to Memtable & CommitLog
                packet.style.transition = 'all 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55)';
                packet.style.transform = 'translate(100px, -45px)';

                setTimeout(() => {
                    if (mem) mem.classList.add('bg-amber-400', 'scale-110', 'transition-transform');
                    if (cl) cl.classList.add('bg-stone-600', 'scale-105', 'transition-transform');
                    packet.style.opacity = '0';
                    status.innerHTML = "<span class='text-amber-600 font-bold'>2. Write Success!</span> (메모리에 썼으므로 Client에게 성공 응답)";

                    // Step 2: Flush (Async)
                    setTimeout(() => {
                        status.innerHTML = "3. Flush Triggered (Memtable이 꽉 찼다고 가정)";
                        packet.style.transition = 'none';
                        packet.style.transform = 'translate(100px, -45px)';
                        setTimeout(() => {
                            packet.style.opacity = '1';
                            packet.style.transition = 'all 1.0s ease-in-out';
                            packet.style.transform = 'translate(180px, 0px)'; // Move to SSTable

                            setTimeout(() => {
                                if (ss) ss.classList.add('bg-stone-800', 'text-white', 'scale-110', 'transition-transform');
                                if (mem) mem.classList.remove('bg-amber-400', 'scale-110');
                                packet.style.opacity = '0';
                                status.innerHTML = "<span class='text-stone-600 font-bold'>4. Data Persisted to SSTable (Immutable)</span>";

                                setTimeout(() => {
                                    if (ss) ss.classList.remove('bg-stone-800', 'text-white', 'scale-110');
                                    if (cl) cl.classList.remove('bg-stone-600', 'scale-105');
                                    status.innerHTML = "";
                                }, 2000);
                            }, 1000);
                        }, 100);
                    }, 2000); // Wait 2s before flushing
                }, 800);
            }, 100);
        }

        function initRadarChart() {
            const canvas = document.getElementById('radarChart'); if (!canvas) return;
            const ctx = canvas.getContext('2d'); if (charts['radar']) charts['radar'].destroy();
            charts['radar'] = new Chart(ctx, { type: 'radar', data: { labels: ['가용성', '일관성', '쓰기 속도', '읽기 속도', '수평 확장성', '장애 내성'], datasets: [{ label: 'MySQL', data: [6, 10, 5, 9, 3, 5], backgroundColor: 'rgba(168, 162, 158, 0.1)', borderColor: '#a8a29e', borderWidth: 1.5 }, { label: 'Cassandra', data: [10, 4, 10, 8, 10, 10], backgroundColor: 'rgba(245, 158, 11, 0.2)', borderColor: '#f59e0b', borderWidth: 2 }] }, options: { maintainAspectRatio: false, scales: { r: { beginAtZero: true, max: 10, ticks: { display: false } } } } });
        }

        function initBarChart() {
            const canvas = document.getElementById('barChart'); if (!canvas) return;
            const ctx = canvas.getContext('2d'); if (charts['bar']) charts['bar'].destroy();
            charts['bar'] = new Chart(ctx, { type: 'bar', data: { labels: ['Default', 'ZGC', 'OS Tuning', 'Speculative Retry'], datasets: [{ label: 'P99 Latency (ms)', data: [135, 80, 45, 8], backgroundColor: ['#e7e5e4', '#fbbf24', '#f59e0b', '#b45309'], borderRadius: 12 }] }, options: { maintainAspectRatio: false, scales: { y: { beginAtZero: true } } } });
        }

        function simCompaction(type) {
            const area = document.getElementById('compaction-area');
            const desc = document.getElementById('sim-desc');
            area.innerHTML = '';

            if (type === 'STCS') {
                desc.innerText = "STCS: 비슷한 크기(Size)의 SSTable 4개가 모이면 하나로 병합합니다.";
                // Initial state
                for (let i = 0; i < 4; i++) area.innerHTML += `<div class="w-8 h-12 bg-amber-200 border border-amber-400 rounded transition-all duration-500" id="s-${i}"></div>`;
                setTimeout(() => {
                    area.innerHTML = `<div class="w-32 h-16 bg-amber-500 border border-amber-700 rounded flex items-center justify-center text-white font-bold text-xs animate-bounce">Merged</div>`;
                }, 1000);
            } else if (type === 'LCS') {
                desc.innerHTML = "LCS (Leveled): <strong>L0 (Memtable)</strong>이 꽉 차면 <strong>L1</strong>으로 내리고, L1이 꽉 차면 <strong>L2</strong>로 병합합니다. <br><span class='text-blue-500 font-bold'>Read 최적화: 각 레벨에서 키 범위가 겹치지 않음!</span>";

                // Setup Layout: L0, L1, L2
                area.innerHTML = `
                <div class="w-full h-full flex flex-col justify-between p-2 gap-2 relative">
                    <!-- Level 0 -->
                    <div class="flex items-center gap-2 h-10 border-b border-stone-200">
                        <span class="text-[10px] font-bold text-stone-400 w-6">L0</span>
                        <div id="l0-container" class="flex gap-1"></div>
                    </div>
                    <!-- Level 1 -->
                    <div class="flex items-center gap-2 h-10 border-b border-stone-200">
                        <span class="text-[10px] font-bold text-stone-400 w-6">L1</span>
                        <div id="l1-container" class="flex gap-1"></div>
                    </div>
                    <!-- Level 2 -->
                    <div class="flex items-center gap-2 h-10">
                        <span class="text-[10px] font-bold text-stone-400 w-6">L2</span>
                        <div id="l2-container" class="flex gap-1"></div>
                    </div>
                </div>`;

                // Step 1: Fill L0
                const l0 = document.getElementById('l0-container');
                const l1 = document.getElementById('l1-container');
                const l2 = document.getElementById('l2-container');

                for (let i = 0; i < 4; i++) {
                    setTimeout(() => {
                        l0.innerHTML += `<div class="w-6 h-6 bg-amber-300 rounded border border-amber-500 shadow-sm animate-pulse"></div>`;
                    }, i * 200);
                }

                // Step 2: Flush to L1
                setTimeout(() => {
                    l0.innerHTML = ''; // Clear L0
                    for (let i = 0; i < 4; i++) {
                        l1.innerHTML += `<div class="w-6 h-6 bg-blue-300 rounded border border-blue-500 shadow-sm transition-all duration-500 transform translate-y-0"></div>`;
                    }
                }, 1200);

                // Step 3: Merge to L2
                setTimeout(() => {
                    l1.innerHTML = ''; // Clear L1
                    l2.innerHTML += `<div class="w-24 h-8 bg-indigo-500 rounded border border-indigo-700 shadow-md flex items-center justify-center text-white text-[10px] font-bold">L1-Merged to L2</div>`;
                }, 2500);
            } else if (type === 'TWCS') {
                desc.innerText = "TWCS: 시간(Window)이 지나면 새로운 버킷을 만듭니다. 오래된 버킷은 통째로 삭제됩니다.";
                area.innerHTML = `<div class="flex gap-4 items-end h-full">
                    <div class="flex flex-col gap-1 items-center"><div class="w-10 h-20 bg-stone-300 rounded opacity-50"></div><span class="text-[9px]">과거</span></div>
                    <div class="flex flex-col gap-1 items-center"><div class="w-10 h-20 bg-emerald-400 rounded shadow-lg"></div><span class="text-[9px]">현재</span></div>
                </div>`;
                setTimeout(() => {
                    area.children[0].innerHTML = `<div class="w-10 h-20 border-2 border-dashed border-red-400 rounded flex items-center justify-center text-[8px] text-red-500 font-bold">DROPPED</div><span class="text-[9px]">과거</span>`;
                }, 1000);
            }
        }

        function toggleProgress(topicId) { taskStatus[topicId] = !taskStatus[topicId]; localStorage.setItem('cassandra_team_progress', JSON.stringify(taskStatus)); updateOverallProgress(); renderSidebar(); }
        function updateOverallProgress() { let total = 0; let completed = 0; phases.forEach(p => p.topics.forEach(t => { total++; if (taskStatus[t.id]) completed++; })); const percent = Math.round((completed / total) * 100); const pb = document.getElementById('total-progress-bar'); const pt = document.getElementById('progress-text'); if (pb) pb.style.width = percent + '%'; if (pt) pt.innerText = percent + '%'; }
        function goBack() { if (currentTopicIdx > 0) changeTopic(currentPhaseIdx, currentTopicIdx - 1); else changePhase(currentPhaseIdx); }
        function goNext() { const phase = phases[currentPhaseIdx]; if (currentTopicIdx < phase.topics.length - 1) changeTopic(currentPhaseIdx, currentTopicIdx + 1); else if (currentPhaseIdx < phases.length - 1) changePhase(currentPhaseIdx + 1); }

        function runHASimAction(action) {
            const na = document.getElementById('ha-node-a');
            const nb = document.getElementById('ha-node-b');
            const nc = document.getElementById('ha-node-c');
            const badge = document.getElementById('hint-badge-a');
            const log = document.getElementById('ha-log');
            if (!na) return;

            const time = new Date().toLocaleTimeString().split(' ')[0];
            const logMsg = (msg, color = 'text-stone-300') => {
                log.innerHTML += `<div><span class="text-stone-500">[${time}]</span> <span class="${color}">${msg}</span></div>`;
                log.scrollTop = log.scrollHeight;
            };

            if (action === 'kill') {
                if (na.classList.contains('bg-stone-400')) return; // Already dead
                na.classList.remove('bg-emerald-500');
                na.classList.add('bg-stone-400', 'opacity-50');
                na.innerText = "DOWN";
                logMsg("🔥 Node A is DOWN! (Connection Refused)", "text-red-400");
            }
            else if (action === 'revive') {
                if (!na.classList.contains('bg-stone-400')) return; // Already alive
                na.classList.remove('bg-stone-400', 'opacity-50');
                na.classList.add('bg-emerald-500');
                na.innerText = "A";
                logMsg("🚑 Node A is UP (Handshake Complete)", "text-green-400");

                // Replay Hint
                if (!badge.classList.contains('hidden')) {
                    setTimeout(() => {
                        badge.classList.add('hidden');
                        logMsg("✅ Hint Handed off: B -> A (Data Synced)", "text-blue-400");
                    }, 1000);
                }
            }
            else if (action === 'write') {
                logMsg("💾 Write Request (CL=QUORUM)...");

                // Normal write to B, C
                nb.classList.add('ring-4', 'ring-sky-300');
                nc.classList.add('ring-4', 'ring-sky-300');
                setTimeout(() => {
                    nb.classList.remove('ring-4', 'ring-sky-300');
                    nc.classList.remove('ring-4', 'ring-sky-300');
                }, 500);

                // Check A
                if (na.classList.contains('bg-stone-400')) {
                    // Fail -> Hint
                    logMsg("⚠️ Node A Unreachable! Storing Hint on B.", "text-yellow-400");
                    badge.classList.remove('hidden');
                } else {
                    // Success
                    na.classList.add('ring-4', 'ring-sky-300');
                    setTimeout(() => na.classList.remove('ring-4', 'ring-sky-300'), 500);
                    logMsg("✅ Write Success (3/3 Replicas)", "text-blue-400");
                }
            }
        }

        window.onload = init;
    </script>
</body>

</html>